1.	Протокол HTTP, основные свойства HTTP, структура запроса и ответа. Понятие web-приложения, структура и принципы работы web-приложения. Понятие асинхронности.
Протокол – набор соглашений и правил, определяющих порядок обмена информацией в компьютерной сети.
HTTP (англ. HyperText Transfer Protocol — «протокол передачи гипертекста») — протокол прикладного уровня передачи данных (изначально — в виде гипертекстовых документов).
Основой HTTP является технология «клиент-сервер», то есть предполагается существование клиентов, которые инициируют соединение и посылают запрос, и серверов, которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.
HTTP в настоящее время повсеместно используется во Всемирной паутине для получения информации с веб-сайтов.
**Структура http: стартовая строка,  
HTTP: основные свойства 
-	версии HTTP/1.1 – действующий (текстовый), HTTP/2 – черновой (не распространен, бинарный); 
-	два типа абонентов: клиент и сервер;
-	два типа сообщений: request и response;
-	от клиента к серверу – request;
-	от сервера к клиенту – response;
-	на один request всегда один response, иначе ошибка;
-	одному response всегда один request, иначе ошибка; 
-	TCP-порты: 80, 443;
-	для адресации используется URI или URN;
-	поддерживается W3C, описан в нескольких RFC.
	HTTP — протокол прикладного уровня, аналогичными ему являются FTP и SMTP.
Обмен сообщениями идёт по обыкновенной схеме «запрос-ответ». Для идентификации ресурсов HTTP использует глобальные URI. В отличие от многих других протоколов, HTTP не сохраняет своего состояния. Это означает отсутствие сохранения промежуточного состояния между парами «запрос-ответ». Компоненты, использующие HTTP, могут самостоятельно осуществлять сохранение информации о состоянии, связанной с последними запросами и ответами. Браузер, посылающий запросы, может отслеживать задержки ответов. Сервер может хранить IP-адреса и заголовки запросов последних клиентов. Однако сам протокол не осведомлён о предыдущих запросах и ответах, в нём не предусмотрена внутренняя поддержка состояния, к нему не предъявляются такие требования.
**Заголовки
-	General: общие заголовки, используются в запросах и ответах;
-	Request: используются только в запросах;
-	Response: используются только в ответах;
-	Entity: для сущности в ответах и запросах.
Метод HTTP — последовательность из любых символов, кроме управляющих и разделителей, указывающая на основную операцию над ресурсом. Обычно метод представляет собой короткое английское слово, записанное заглавными буквами. Обратите внимание, что название метода чувствительно к регистру.
**Основные методы
Веб-приложение — клиент-серверное приложение, в котором клиент взаимодействует с веб-сервером при помощи браузера. Логика веб-приложения распределена между сервером и клиентом, хранение данных осуществляется, преимущественно, на сервере, обмен информацией происходит по сети. Одним из преимуществ такого подхода является тот факт, что клиенты не зависят от конкретной операционной системы пользователя, поэтому веб-приложения являются межплатформенными службами.
web-приложения - Веб-приложения — клиент-серверное приложение в котором клиент взаимодействует с сервером по протоколу HTTP.
URI: Uniform Resource Identifier – унифицированный идентификатор ресурса (документ, изображение, файл, служба, электронная почта, …).
URL: Uniform Resource Location - унифицированный локатор ресурса, содержащий местонахождение ресурса и способ обращения (протокол) к ресурса, описывает множество URI.
URN: Uniform Resource Name - унифицированное имя ресурса – URI, имя ресурса, не содержащее месторасположение и способ доступа к ресурсу. В будущем URN должен заменить URL (для решения проблем с перемещением ресурсов в Internet).
URI, URL, URN – рекомендуется использовать термин URI  
Для взаимодействия между клиентом и сервером в соответствии с правилами (спецификацией, протоколом) должно быть установлено соединение; инициатором соединения всегда является клиент.  
Понятие асинхронности: операция называется асинхронной, если ее выполнение  осуществляется в 2 фазы: 1) заявка на исполнение; 2) получение результата; при этом участвуют два механизма: A-механизм, формирующий заявку и потом  получающий результат; B-механизм, получающий заявку от A, исполняющий операцию и отправляющий результат A; продолжительность исполнения операции B-механизмом, как правило, непредсказуемо; в то время пока B-механизм исполняет операцию, А-механизм выполняет собственную работу. Применение асинхронности не противоречит применению многопоточности.      


2.	Web-сервер. Ресурсы, потребляемые web-сервером. Блокирующие и неблокирующие операции ввода/вывода. Решение проблемы блокирующего ввода/вывода. Понятия конкурентность и параллельность. Закон Амдала.
серверная части web-приложения или иначе web-сервер
Web-ресурс приложения: сущность, расположенная на стороне сервера и имеющая URL/URI, к которой можно сделать http-запрос и получить http-ответ.  Одно web-приложение представлено одним или более ресурсов.
Web-ресурсы приложения: статические - отправляются клиенту без изменения (html-страницы, рисунки, видео-файлы, …),  динамические – динамически (программно) формируются на сервере и отправляются клиенту (сервлеты, JSP, http-обработчики, aspx-страницы,…). Ресурс может быть статическим относительно сервера и динамическим относительно клиента (html-страницы с JavaScript).  
подхода для решения проблем блокирующего ввода/вывода: 1) применение многопоточности (ограничение по количеству потоков, каждый поток требует  дополнительной памяти); 2) применение паттерна Reactor. Apache – многопоточность, Nginx – Reactor. паттерн Reactor – шаблон проектирования. Используется при обработке параллельных запросов к сервису. Сервисный обработчик разбирает прибывшие запросы и синхронно перенаправляет их на соответствующие обработчики запросов.
Конкурентность — это выполнение задач за определённое время (например, есть 5 процессов и все они в сумме выполняются в течение 60 минут по очереди). Важная деталь заключается в том, что задачи необязательно выполняются одновременно, поэтому их можно разделить на более мелкие и чередующиеся.
Параллелизм — это выполнение задач в одно и то же время (например, есть 5 задач, каждая из них выполняется в течение 60 минут). Само название подразумевает, что они выполняются параллельно.
Зако́н Амдала  — иллюстрирует ограничение роста производительности вычислительной системы с увеличением количества вычислителей.
закон Амдала, ограниченность возможностей, speedup – кратность прироста скорости вычисления, parallel portion – степень распараллеливания алгоритма (не все можно распараллелить), number of processors – количество процессоров.    

3.	Протокол WebSockets, основные свойства, процедура установки соединения. WebSockets API.  
При полудуплексном типе связи оба абонента имеют возможность принимать и передавать сообщения. Каждый узел имеет в своём составе и приёмник, и передатчик, но одновременно они работать не могут. В каждый момент времени канал связи образуют передатчик одного узла и приёмник другого.
По дуплексному каналу данные могут передаваться в обе стороны одновременно. Каждый из узлов связи имеет приёмник и передатчик. После установления связи передатчик первого абонента соединяется с приёмником второго и наоборот.
WebSocket представляет собой альтернативу HTTP, его можно применять для организации обмена данными в веб-приложениях. Этот протокол позволяет создавать долгоживущие двунаправленные каналы связи между клиентом и сервером. После установления соединения канал связи остаётся открытым, что даёт в распоряжение приложения очень быстрое соединение, характеризующееся низкими задержками и небольшой дополнительной нагрузкой на систему.
Протокол WebSocket поддерживают все современные браузеры.
HTTP и WebSocket — это очень разные протоколы, в которых используются различные подходы к обмену данными. HTTP основан на модели «запрос — ответ»: сервер отправляет клиенту некие данные после того, как они будут запрошены. В случае с WebSocket всё устроено иначе. А именно:
· Сервер может отправлять сообщения клиенту по своей инициативе, не дожидаясь поступления запроса от клиента.
· Клиент и сервер могут обмениваться данными одновременно.
· При передаче сообщения используется крайне малый объём служебных данных. Это, в частности, ведёт к низким задержкам при передаче данных.
Протокол WebSocket очень хорошо подходит для организации связи в режиме реального времени по каналам, которые долго остаются открытыми. HTTP, в свою очередь, отлично подходит для организации эпизодических сеансов связи, инициируемых клиентом. В то же время надо отметить, что, с точки зрения программирования, реализовать обмен данными по протоколу HTTP гораздо проще, чем по протоколу WebSocket.

Кратко, как проходит переход на ws:
Клиент отправляет запрос с Connection: Upgrade, Upgrade: websocket, Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==
Sec-WebSocket-Version: 13
 
Если сервер может перейти на ws, то он отправляет ответ с заголовками Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g= - ключ основан на ключе пользователя, в спецификации описано, как он генерируется

HTTP/1.1 101 Switching Protocols
Произошло рукопожатии

**Показать пинг-понг


4.	Платформа Node.js, версии, назначение, основные свойства, структура, принципы работы, основные встроенные модули и их назначение, применение внешних модулей (пакетов). Web-приложение «Hello World». Пример. 
--Теория--
Платформа Node.js - программная платформа для разработки  серверных web-приложений на языке JS/V8.
1.	основные свойства:
-	основан на Chrome V8;
-	среда (контейнер) исполнения приложений на JavaScript;
-	поддерживает механизм асинхронности;
-	ориентирован на события;
-	однопоточный (код приложения исполняется только в одном потоке, один стек вызовов); обычно в серверах для каждого соединения создается свой поток, в Node.js все соединения обрабатываются в одном JS-потоке;
-	не блокирует выполнение кода при вводе/выводе (в файловой системе до 4х одновременно);
-	в состав Node.js входят инструменты: npm – пакетный менеджер; gyp - Python-генератор проектов; gtest – Google фреймворк для тестирования С++ приложений;   
-	использует библиотеки: V8 – библиотека V8 Engine, libuv – библиотека для абстрагирования неблокирующих операций ввода/вывода (представляет собой обертку над epoll, kqueue, IOCP); llhttp – легковесный парсер http-сообщений (написан на C и не выполняет никаких системных вызовов); c-ares - библиотека для работы с DNS; OpenSSL – библиотека для криптографии; zlib – сжатие и распаковка.
-	первая версия: 2009 г.;
-	стабильные версии: с 2015 г., Node.js 4.0.0;
-	основная сфера применения: разработка web-серверов;
версионирование: две ветки 12.x.x – версии длительной поддержки (LST, Long Term Support), 14.x.x – нестабильные версии, включающие последние разработки (Current).
**v8
Встроенные пакеты - это пакеты, которые доступны по умолчанию, т.е. мы их не докачиваем
fs - To handle the file system
http - To make Node.js act as an HTTP server
querystring - To handle URL query strings
url - To parse URL strings
util - To access utility functions

5.	Глобальные объекты Node.js (global, process) и их применение. Системные (стандартные потоки) Node.js (stdin, stdout, stderr) и их применение. Модуль console: функции log, error, dir, time, timeEnd, trace. Примеры.
--Теория--
global: хранит var-данные на уровне модуля.
2.	process: информация о среде выполнения 
Node.js предоставляет специальный объект global, который предоставляет доступ к глобальным, то есть доступным из каждого модуля приложения, переменным и функциям.
Объект Process является экземпляром EventEmitter и запускает следующие события: 
Exit — Запускается при выходе из процесса. В этот момент невозможно предотвратить выход из цикла событий, после того как все прослушиватели выхода закончатся, процесс завершится.
beforeExit — Это событие запускается, когда node очищает цикл событий и на данный момент не существует других событий, которые должны быть запланированы. Как правило, когда больше не существует запланированных задач, осуществляется выход из node, но прослушиватель для «beforeExit» может выполнять асинхронные вызовы и продолжать работу node.
uncaughtException — Запускается, когда в цикле событий снова и снова возникает исключение. Если для этого исключения добавлен прослушиватель, действие по умолчанию (которое должно вывести результаты текущей операции в стеке и завершить процесс) выполняться не будет.
Процесс предоставляет много важных свойств, для лучшего контроля системного взаимодействия.

Stdout — Записываемый поток в stdout.
Stderr — Записываемый поток в stderr.
Stdin — Записываемый поток для stdin.
argv — Массив, содержащий аргументы командной строки. Первый элемент — «node», второй элемент — имя файла JavaScript.Следующие элементы — любые дополнительные аргументы командной строки.
Env — Объект, содержащий пользовательскую среду.
Log - Выводит в stdout данные с новой строки.
Error - Выводит в stderr данные с новой строки
Dir - Отображает список свойств указанного JavaScript объекта.
Time - Запускает таймер, который используется для вычисления длительности операции. timeEnd - станавливает таймер, запущенный предыдущей функцией. Выводит результат в stdout:
 Trace- Выводит в stderr строку 'Trace :' c форматированным сообщением из util.format() и отслеживает его текущую позицию в коде.

--Практика--
console:

console.log('Выводит в stdout данные с новой строки. Можно передавать множественные аргументы: первый будет использоваться как основное сообщение, а дополнительные – как значения замещения, по типу printf(3)');
console.error('Выводит в stderr данные с новой строки. Можно передавать множественные аргументы: первый будет использоваться как основное сообщение, а дополнительные – как значения замещения, по типу printf(3)');

let obj = {
    x: 1,
    y: 2
};
//Использует util.inspect() в obj и выводит полученную строку в stdout.
console.dir(obj);

/*Запускает таймер, который используется для вычисления длительности операции.
Таймеры идентифицируются с помощью уникального label.
Для остановки таймера и вывода времени в миллисекундах в stdout,
нужно использовать этот label при вызове console.timeEnd().
Показания таймера точны до миллисекунд.*/
console.time('100-elements');
for (let i = 0; i > 100; i++) { ; }
//Останавливает таймер, запущенный предыдущей функцией. Выводит результат в stdout
console.timeEnd('100-elements');

//Выводит в stderr строку 'Trace :' c форматированным сообщением из util.format() и отслеживает его текущую позицию в коде.
console.trace('Show me');
      
global:

let currentDate = new Date();

//установка глобальной переменной
global.date = currentDate;

//в модуле получаем глобальную переменную name, которая будет установлена из вне.
// При этом обратиться к глобальной переменной name мы можем через объект global:
// global.name, либо просто через имя name, так как переменная глобальная.
module.exports.getMessage = function() {
    let hour = currentDate.getHours();
    if(hour > 22) {
        return "Good night, " + global.name;
    }
    else if(hour > 16) {
        return "Good evening, " + name;
    }
    else if(hour > 10) {
        return "Good afternoon, " + name;
    }
    else {
        return "Good morning, " + name;
    }
};

process:

/*Любое приложение созданное на Node.js — это экземпляр объекта Process,
который наследует все свойства и методы этого объекта.
С помощью этих свойств и методов мы можем получить информацию о приложении и контексте его исполнения. */

//возвращает абсолютный путь к исполняемому файлу, который запустил процесс Node.js.
console.log(process.execPath);
//возвращает версию Node.js
console.log(process.version);
//возвращает строку, определяющую платформу операционной системы, на которой запущен процесс
console.log(process.platform);
//возвращает строку, определяющую архитектуру процессора, на котором на текущий момент запущен Node.js
console.log(process.arch);
//возвращает заголовок текущего процесса (например, возвращает текущее значение ps)
console.log(process.title);
//возвращает PID процесса
console.log(process.pid);

const greeting = require("./global");

//возвращает открытый для чтения стрим
process.stdin.setEncoding('utf8');

process.stdin.on('readable', () => {
    global.name = process.stdin.read();
    if (global.name !== null) {
        global.console.log(date);
        console.log(greeting.getMessage());
    }
});

//Завершает процесс с указанным кодом. Если опустить параметр, exit использует код «success» - 0.
process.on('exit', (code) => {
    console.log(`About to exit with code: ${code}`);
});


stream:

const http = require('http');
let state = 'norm';

http.createServer(function(request, response) {
    response.writeHead(200, {'Content-Type': 'text/html; charset=utf-8'});
    response.end('<h1>' + state + '</h1>');
}).listen(5000);

process.stdin.setEncoding('utf8');
process.stdout.write('Server running at http://localhost:5000/\n');
process.stdout.write(state + '->');

process.stdin.on('readable', () => {
    let chunk = null;
    while ((chunk = process.stdin.read()) != null) {
        if (chunk.trim() === 'norm' || chunk.trim() === 'test' || chunk.trim() === 'stop') {
            process.stdout.write('reg = ' + state + '-->' + chunk.trim() +'\n');
            state = chunk.trim();
            process.stdout.write(state + '->');
        }
        else if (chunk.trim() === 'exit') {
            process.exit(0);
        }
        else if (chunk.trim() === 'err') {
            process.stderr.write('error');
        }
        else {
            process.stdout.write(state + '->');
        }
    }
});


app:

const greeting = require("./global");

//Здесь устанавливаем глобальную переменную name, которую мы получаем в модуле app.js.
global.name = "Anna";

//Причем все глобальные функции и объекты, например, console,
// также доступны внутри global, поэтому мы можем написать и global.console.log(), и просто console.log().
global.console.log(date);
console.log(greeting.getMessage());



6.	Асинхронное программирование. Функция обратного вызова. Проблема "Callback hell" и способы решения. Примеры.
--Теория--
Асинхронное программирование: выполнение процесса в неблокирующем режиме системного вызова, что позволяет потоку программы продолжить обработку.
Понятие асинхронности: операция называется асинхронной, если ее выполнение  осуществляется в 2 фазы: 1) заявка на исполнение; 2) получение результата; при этом участвуют два механизма: A-механизм, формирующий заявку и потом  получающий результат; B-механизм, получающий заявку от A, исполняющий операцию и отправляющий результат A; продолжительность исполнения операции B-механизмом, как правило, непредсказуемо; в то время пока B-механизм исполняет операцию, А-механизм выполняет собственную работу.
callback-функция (функция обратного вызова) — функция, которая передается в качестве параметра другой функции и которая будет вызвана асинхронно обработчиком событий после завершения задачи
Простыми словами: коллбэк — это функция, которая должна быть выполнена после того, как другая функция завершила выполнение (отсюда и название: callback – функция обратного вызова).

Чуть сложнее: В JavaScript функции — это объекты. Поэтому функции могут принимать другие функции в качестве аргументов, а также функции могут возвращать функции в качестве результата. Функции, которые это умеют, называются функциями высшего порядка. А любая функция, которая передается как аргумент, называется callback-функцией. Чтобы лучше разобраться, давайте посмотрим на примерах, как это выглядит.
По одной простой причине: JavaScript — это событийно-ориентированный язык. Это значит, что вместо того, чтобы ждать ответа для дальнейшего выполнения программы, JavaScript продолжит выполнение, одновременно ожидая других событий.

--Практика--
//асинзронность + callback
function a(callback) {
	setTimeout(() => {
		console.log('result of a');
		callback();
	}, 1000)
}
function b(callback) {
	setTimeout(() => {
		console.log('result of b');
		callback();
	}, 1000)
}

a(() => console.log('a() is done'));
console.log('end a')
b(() => console.log('b() is done'));
console.log('end b');
//callback hell
(
	() => {
		let arrOfarr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
		arrOfarr.forEach((arr) => {
			arr.forEach((number) => {
				//next callback operation
				console.log(number);
			})
		})
	}
)();
//разбитие на функции
function printNumber(number) {
	console.log(number);
}
function pringNumberFromArray(arr) {
	arr.forEach((number) => {
		printNumber(number);
	})
}
function printArrayOfArray(arrOfarr) {
	arrOfarr.forEach((arr) => {
		pringNumberFromArray(arr);
	})
}
let arrOfarr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
printArrayOfArray(arrOfarr)
//либо вынести это все в отдельный модуль и сделать
module.export = printArrayOfArray;

7	Асинхронное программирование. Механизм Promises. Механизм async/await. Примеры.
--Теория 
Асинхронное программирование: выполнение процесса в неблокирующем режиме системного вызова, что позволяет потоку программы продолжить обработку.
1.	Понятие асинхронности: операция называется асинхронной, если ее выполнение  осуществляется в 2 фазы: 1) заявка на исполнение; 2) получение результата; при этом участвуют два механизма: A-механизм, формирующий заявку и потом  получающий результат; B-механизм, получающий заявку от A, исполняющий операцию и отправляющий результат A; продолжительность исполнения операции B-механизмом, как правило, непредсказуемо; в то время пока B-механизм исполняет операцию, А-механизм выполняет собственную работу.

Promise (обещание): объект, используемый для выполнения отложенных и асинхронных вычислений. Представляет собой операцию, которая еще не завершена, но ожидается в будущем
Cвойствo state: pending (ожидание), fulfilled (выполнено) при вызове resolve, rejected (отклонено) при вызове reject. Свойство result: вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).
Async/await: синтаксис для обработки нескольких промисов в режиме синхронного кода.
async - перед объявлением функции, возвращает промис; await - блокирует код до тех пор, пока промис не будет разрешен или отклонен.
 --Практика
--index
//Promise

let promise = new Promise((res, rej) => {
   let sum = 3;
   if (sum === 3)
      res("Success")
   else
      rej("Failed")
})
promise.then((res) => {
   console.log("Result: " + res)
}).catch((res) => {
   console.log("Result: " + res)
})

//async/await

async function func() {
   let sum = 3;
   if (sum === 3)
      return "Success"
   else
      throw new Error('Failed')
};
(
   async () => {
      try {
         let res = await func();
         console.log("Result: " + res)
      }
      catch (e) {
         console.log("Result: " + e)
      }
   }
)()
--test
//Promise
let promise = new Promise((res, rej) => {
   let sum = 3;
   if (sum === 3)
      res("Success")
   else
      rej("Failed")
})
promise.then((res) => {
   console.log("Result: " + res)
}).catch((res) => {
   console.log("Result: " + res)
})

//async/await

async function func() {
   let sum = 3;
   if (sum === 3)
      return "Success"
   else
      throw new Error('Failed')
};
(
   async () => {
      try {
         let res = await func();
         console.log("Result: " + res)
      }
      catch (e) {
         console.log("Result: " + e)
      }
   }
)()

8	Класс EventEmitter, назначение, применение. Пример.
--теория
EventEmitter: JS-класс, предоставляющий функциональность для асинхронной обработки событий в Node.js. Событие в программном объекте – это процесс перехода объекта из одного состояние в другое. При этом, об этом переходе могут быть извещены другие объекты. У события есть издатель (или генератор) события и могут быть подписчики (или обработчики) события.     
EventEmitter: применяется в базовых объектах Node.js.
необходимо включения двух модулей: events и util.
EventEmitter: как правило, применяется в качестве базового для пользовательского объекта. Производный от EventEmitter объект может быть создан с помощью функции inherits модуля utils.  
 
EventEmitter: для наследования можно использовать ключевое слово extends (ES6).

EventEmitter: производный от EventEmitter объект приобретает функциональность, позволяющую генерировать и прослушивать события. 

EventEmitter: для генерации событий предназначена функция emit, а для прослушивания функция on. 
--практика
--eventEmitterModule
let util = require('util');
let ee = require('events');

let db_data = [
   { id: 1, name: 'Иванов И.И', bday: '2001-01-01' },
   { id: 2, name: 'Петров П.П', bday: '2001-01-02' },
   { id: 3, name: 'Сидоров С.С', bday: '2001-01-03' }
]

function DB() {
   this.get = () => db_data;
   this.post = (r) => db_data.push(r);
}

util.inherits(DB, ee.EventEmitter);

exports.DB = DB;
--index.html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Document</title>
</head>
<body>
   <div id="getResult"></div>
   <button onclick="Get()">Get</button>
   <div>
      <div>
         <label for="id">ID</label>
         <input type="number" id="id" min="0"/>
      </div>
      <div>
         <label for="Name">FIO</label>
         <input type="text" id="Name"/>
      </div>
      <div>
         <label for="BDay">Birthday</label>
         <input type="date" id="BDay"/>
      </div>
      <div>
         <button onclick="Post()">POST</button>
      </div>
   </div>
   <script>
      function Post(){
         console.log('POST');
         fetch('http://localhost:3000/api/db',{
            method: 'POST', mode: 'no-cors',
            headers: {'Content-Type': 'application/json','Accept':'application/json'},
            body: JSON.stringify({id:id.value,name: Name.value, bday:BDay.value })
         })
         .then(res => res.json())
         .then(pdata => console.log('POST.pdata',pdata))
      }
      function Get(){
         console.log('Get');
         fetch('http://localhost:3000/api/db',{
            method: 'Get', mode: 'no-cors',
            headers: {'Content-Type': 'application/json','Accept':'application/json'}
         })
         .then(res => res.json())
         .then(pdata => {
            console.log('POST.pdata',pdata);
            getResult.innerHTML = '';
            pdata.forEach(element => {
               getResult.innerHTML +=(element.id + ' ' + element.name+ ' '+ element.bday+'<br/>')
            });
         })
      }
   </script>
</body>
</html>
--index.js
let http = require('http');
let url = require('url');
let fs = require('fs');
let data = require('./eventEmitterModule');

let db = new data.DB();

db.on('GET', (req, res) => {
   console.log('DB GET');
   res.end(JSON.stringify(db.get()));
});
db.on('POST', (req, res) => {
   console.log('DB POST');
   req.on('data', data => {
      let result = JSON.parse(data);
      db.post(result);
      res.end(JSON.stringify(result));
   })
});

//можно через POSTMAN тогда можно не возвращать html
http.createServer((req, res) => {
   if (url.parse(req.url).pathname === '/') {
      let html = fs.readFileSync('./index.html');
      res.writeHead(200, {
         'Content-Type': 'text/html; charset=utf-8'
      })
      res.end(html);
   }
   else if (url.parse(req.url).pathname === '/api/db') {
      db.emit(req.method, req, res)
   }
}).listen(3000)
console.log('start');

9	Функции setTimeout, setInterval, nextTick, ref, unref, назначение,  применение. Примеры.
-теория
Event Loop: макрозадачи - выполняются по одной за один проход цикла; микрозадачи - на каждом проходе цикл выполняет все накопившееся.

Макрозадачи: setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI rendering

Микрозадачи: process.nextTick, Object.observe, Promises

Микро-задачи: специальная функция queueMicrotask (func) -  ставит func в очередь на выполнение в очереди микрозадач.
Вы могли заметить, что process.nextTick() не отображался на диаграмме, даже если он является частью асинхронного API. Это связано с тем, что process.nextTick() технически не является частью цикла событий. Вместо этого nextTickQueue будет обрабатываться после завершения текущей операции, независимо от текущей фазы цикла событий.
Таймер: механизм, позволяющий генерировать событие или выполнить некоторое действие, через заданный промежуток времени. 
setTimeout(), setInterval(); реализованы библиотекой libuv.

setTimeout(): выполняется только один раз через некоторый промежуток времени.
setInterval(): выполняется регулярно через некоторый промежуток времени.
clearTimeout(): останавливает таймер, созданный с помощью setTimeout(). Параметр – ID таймера, который необходимо отменить.
clearInterval():останавливает таймер, созданный посредством setInterval(). Параметр – ID таймера, который необходимо отменить.
NODEJS: Node.js работает до тех пор, пока есть события, требующие обработки; если выполнить для таймера unref, то события, генерируемые таймером не будут учитываться при завершении работы Node.js, ref – противоположная операция. 
метод unref() есть не только у таймеров, есть еще у серверов (server.unref()), сетевых сокетов (socket.unref()) и др.
-- практика
--index.js
setTimeout(() => {
   console.log('1');
}, 0)
setImmediate(() => {
   console.log('2');
})
let interval = setInterval(() => {
   console.log('3');
})
interval.unref();
process.nextTick(() => {
   console.log('4');
}, 0);

1.	10 Модули и пакеты Node.js, функция require, кэширование модуля, область видимости в пакете,   экспорт объектов, функций, конструкторов. Применение require для работы с json-файлами. Параметризируемый модуль. Пример.
--теория
модуль – фрагмент кода, специальным образом оформленный и размещенный, может использоваться приложением, является фундаментальной единицей структурирования кода Node.js-приложений.
модуль – текстовый файл, содержащий код на языке JS
модуль используемый несколькими приложениями называют пакетом.
CommonJS: группа, которая проектирует, прототипирует и стандартизирует различные JavaScript API 

реализованные требования CommonJS
-	поддержка require для импорта модуля;
-	имя модуля – строка, может включать символы идентификации путей;
-	модуль должен явно экспортировать всю свою функциональность, поддержка объекта export; 
-	переменные внутри модуля не видимы за его пределами.   
require
-	сихронно загружает модуль;
-	кэширует модуль;
-	удалить из кэша можно с помощью delete require.cache[…];
-	если модуль удален, то для его использования нужен новый require.
Для локального пакета поиск осуществляется в node_modules  по восходящему принципу. После поиска среди локальных пакетов, осуществляется поиск среди глобальных пакетов. 
NODEJS: require: если в качестве имени  указана папка, то дополнительная информация в файле package.json
Var дает видимость только внутри пакеты 
Global и process глобально во всем приложении exports позваляет использовать эти переменные/функции при использовании пакета 




--практика
--index.js
//let m1 = require('./m-1')('hello');
let m1 = require('./m-1');

m1.print('hi')
console.log('y: ' + global.y);
console.log('z: ' + process.z);
console.log(m1.calcWithNumberOneAndTwo.add())
console.log(new m1.Calc(2, 2).sub());
console.log('CACHE1: ')
console.log(require.cache);
delete require.cache[require.resolve('./m-1.js')];
console.log('CACHE2: ')
console.log(require.cache);
-m-1
var x = 1;
global.y = 2;
process.z = 3;
console.log(x)
console.log(y)
//console.log(z) -error
console.log(global.x)
console.log(global.y)
console.log(global.z)
console.log(process.x)
console.log(process.y)
console.log(process.z)

function Calc(a, b) {
   this.a = a;
   this.b = b;
   this.add = () => this.a + this.b
   this.sub = () => this.a - this.b
}

let calcWithNumberOneAndTwo = new Calc(1, 2)


//пример передачи параметра
// module.exports = function (message) {
//     console.log(message);
// }

exports.calcWithNumberOneAndTwo = calcWithNumberOneAndTwo;
exports.Calc = Calc;
exports.print = function print(message) {
   console.log(message);
} 

11 Пакетный менеджер NPM, глобальное хранилище, просмотр установленных пакетов, скачивание пакетов, назначение файла package.json, локальные хранилища пакетов, удаление пакетов, публикация пакета. Примеры.
JavaScript Package Manager, устанавливается вместе с Node.js, скачивание /публикация пакетов; инструмент командной строки; глобальное хранилище https://registry.npmjs.org/
NPM: https://www.npmjs.com/ 

NPM: пакет – один или несколько js-файлов и файл-манифест package.json 
просмотр установленных пакетов: 
npm list –g --depth=0 
ls, la, ll – 
скачивание пакетов: install, i
add is just an alias for install.
 глобально установить добавить -g
назначение файла package.json:
package.json: файл конфигурации приложения Node.js. Любая директория, содержащая данный файл, интерпретируется как Node.js-пакет.
package.json: содержит метаданные проекта (название, версия, описание проекта, …), список зависимостей вашего пакета, которые будут установлены при вызове команды npm install, скрипты, вызывающие другие команды консоли.
локальные хранилища пакетов:
node_modules – папка в которой сохраняются npm 
 удаление пакетов:
npm uninstall <name> удаляет модуль из node_modules, но не package.json
npm uninstall <name> --save также удаляет его из dependencies в package.json
npm uninstall <name> --save-dev также удаляет его из devDependencies в package.json
npm -g uninstall <name> --save также удаляет его глобально

 публикация пакета:
Чтобы опубликовать пакет, вам потребуется собрать все исходные коды и файл package.json в одной директории. В package.json должны быть указаны название, версия и зависимости пакета. Например:
{ "name": "canvas-project", "version": "0.1.0", "devDependencies": { "canvas-chart": "~1.3.0" } }
Посмотрев на этот код, мы можем сказать, что пакет «canvas-project» зависит от пакета «canvas-chart». Опубликовать пакет можно с помощью комадны npm publish.
- практика 
-index
let mod = require('my-arc-module');
mod.print('help');
-module
exports.print = (message) => {
   console.log(message);
}

12 Разработка простейшего HTTP-сервера в Node.js. Извлечение данных из HTTP-запроса, формирование данных HTTP-ответа.  Пример. Тестирование с помощью POSTMAN.

--теория
HTTP-сервер: серверная часть web-приложения.
JSON: JavaScript Object Notation, текстовый формат передачи данных, автор: Дуглас Крокфорд.
'101': 'Switching Protocols',
'200': 'OK',
'201': 'Created',
'204': 'No Content',
'301': 'Moved Permanently',
'302': 'Moved Temporarily',
'304': 'Not Modified',
'307': 'Temporary Redirect',
'400': 'Bad Request',
'401': 'Unauthorized',
'403': 'Forbidden',
'404': 'Not Found',
'405': 'Method Not Allowed',
'409': 'Conflict',
'500': 'Internal Server Error',

Медиа тип (так же известный как Multipurpose Internet Mail Extensions или MIME тип) является стандартом, который описывает природу и формат документа, файла или набора байтов. О
-- практика (12-13)
--index.html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Document</title>
</head>
<body>
   <button onclick="getInfo()">start</button>
   <script>
      async function getInfo(){
         let res = await fetch('http://localhost:3000/info');
         console.log(res);
         let data = await res.text();
         document.write(data);
      // function getInfo2(){
      //     let req = new XMLHttpRequest();
      //           req.open('GET', 'http://localhost:3000/info', true);
      //           req.onreadystatechange = () => {
      //               if (req.readyState === 4) {
      //                   if (req.status === 200) {
      //                       document.getElementById('text').innerHTML = req.responseText;
      //                   } 
      //                   else {
      //                       console.log(req.statusCode);
      //                   }
      //               }
      //           };
      //     req.send();
      // }
   </script>
</body>
</html>
--index.js
let http = require('http');
let fs = require('fs');
let k = 0;
let c = 0;
let s = '';

let server = http.createServer();

let http_handler = (req, res) => {
   console.log(req.url)
   if (req.url === '/index') {
      let html = fs.readFileSync('./index.html')
      res.writeHead(200, { 'Content-Type': 'text/html; charset=utf8' });//записать заголовок
      res.end(html);
   }
   else if (req.url === '/info') {
      console.log(`request url: ${req.url}, #`, ++k);
      res.writeHead(200, { 'Content-Type': 'text/html; charset=utf8' });//записать заголовок
      res.write('<h2>Http-сервер</h2>');//отправить порцию
      s += `url = ${req.url}, request/response # ${c} - ${k}<br/>`;
      res.end(s);
      if (req.url === '/close') {
         server.close(() => console.log('server.close'))
      }
   }
   else {
      res.writeHead(200, { 'Content-Type': 'text/html; charset=utf8' });
      res.end('hi');
   }
}

server.keepAliveTimeout = 10000; //время сохранения соединения connection 5000 - default
server.on('connection', (socket) => {
   console.log(`connection: server.keepAliveTimeout = ${server.keepAliveTimeout}`, ++c);
   s += `<h2>connection # ${c}</h2>`
   console.log('socket.localAddress = ', socket.localAddress)
   console.log('socket.localPort = ', socket.localPort)
   console.log('socket.remoteAddress = ', socket.remoteAddress)
   console.log('socket.remoteFamily = ', socket.remoteFamily)
   console.log('socket.remotePort = ', socket.remotePort)
   console.log('socket.bytesWritten = ', socket.bytesWritten)
})

server.timeout = 10000 //сообщить о бездействии > 10000, умолчание 120000
server.on('timeout', (socket) => {
   console.log('timeout:', server.timeout)
})

server.on('request', http_handler)

server.on('close', () => console.log('server.on.close'))

server.listen(3000, (v) => console.log('start on port 3000'))
   .on('error', (e) => {
      console.log('Error ', e)
   })

14.	Разработка HTTP-сервера в Node.js. Обработка GET, POST, PUT и DELETE-запросов.  Генерация ответа с кодом 405. Пример. Тестирование с помощью POSTMAN.
15.	Разработка HTTP-сервера в Node.js. Обработка URI  HTPP-запроса, маршрутизация запросов, генерация ответа с кодом 404. Пример. Тестирование с помощью POSTMAN.

/*практика для двух этих вопросов ниже*/

let http = require('http');

let HTTP405 = (req, res) => {
	res.writeHead(405);
	res.end(`Wrong METHOD`);
};

let HTTP404 = (req, res) => {
	res.writeHead(404);
	res.end(`Wrong URI`);
};
let urlhandler = (req, res) => {
	if (req.url === '/') {
		res.writeHead(200);
		res.end(`${req.method}:${req.url}`);
	}
	else {
		HTTP404(req, res);
	}
}

let http_handler = (req, res) => {
	switch (req.method) {
		case 'GET': urlhandler(req, res); break;
		case 'POST': urlhandler(req, res); break;
		case 'PUT': urlhandler(req, res); break;
		case 'DELETE': urlhandler(req, res); break;
		default: HTTP405(req, res); break;
	}
};

http.createServer().listen(3000)
	.on('error', (e) => { console.log('error: ', e.code) })
	.on('request', http_handler);
	
	
16.	Разработка HTTP-сервера в Node.js. Обработка запросов к статическим ресурсам: html, css, js, png, msword.  Пример. Тестирование с помощью браузера.
/*практика а также статические ресурсы ниже*/

/*практика*/
let http = require('http');
let fs = require('fs');

writeHTTP404 = (req, res) => {
	res.statusCode = 404;
	res.statusMessage = 'Resourse not found';
	res.end("Resourse not found");
}

isStatic = (ext, fn) => {
	let reg = new RegExp(`^\/.+\.${ext}$`);
	return reg.test(fn);
};

// sendFile = (req, res, headers) => {
// 	fs.access(`./files${req.url}`, err => {
// 		if (err)
// 			this.writeHTTP404(res);
// 		else {
// 			res.writeHead(200, headers);
// 			fs.createReadStream(`./files${req.url}`).pipe(res);
// 		}
// 	});
// };

sendFile = (req, res, headers) => {
	fs.readFile(`./files${req.url}`, (err, result) => {
		if (err)
			this.writeHTTP404(res);
		else {
			res.writeHead(200, headers);
			res.write(result);
			res.end();
		}
	})
};


let http_handler = (req, res) => {
	if (isStatic('html', req.url)) sendFile(req, res, { "Content-Type": "text/html; charset=utf-8;" });
	else if (isStatic('css', req.url)) sendFile(req, res, { "Content-Type": "text/css; charset=utf-8;" });
	else if (isStatic('js', req.url)) sendFile(req, res, { "Content-Type": "text/javascript; charset=utf-8;" });
	else if (isStatic('docx', req.url)) sendFile(req, res, { "Content-Type": "application/msword" });
	else if (isStatic('json', req.url)) sendFile(req, res, { "Content-Type": "application/json" });
	else if (isStatic('png', req.url)) sendFile(req, res, { "Content-Type": "image/png" });
	else writeHTTP404(req, res);
};

http.createServer().listen(3000)
	.on('error', (e) => { console.log('error: ', e.code) })
	.on('request', http_handler);
	
/*статические ресурсы(нужно создать файлы в папке files)*/
 
--css.css
body{
	background: red;
}

--f.docx
asd

--index.html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="./css.css">
	<script src="./temp.js"></script>
	<title>Document</title>
</head>
<body>
	
</body>
</html>

--json.json
{
	"name": "Alex",
	"age": 22
}

temp.js
!!!он без содержимого, просто пустым оставить

text.txt
lorem	sal;djasdajsld


17.	Разработка HTTP-сервера в Node.js. Обработка query-параметров GET-запроса. Пример. Тестирование с помощью браузера.
18.	Разработка HTTP-сервера в Node.js. Обработка path-параметров GET-запроса. Пример. Тестирование с помощью браузера.
/*код для двух этих заданий ниже*/
let http = require('http');
let url = require('url');

let handler = (req, res) => {
	if (req.method = 'GET') {
		let p = url.parse(req.url, true);
		let result = '';
		result = `path: ${decodeURI(p.path)}<br/>`;
		let q = url.parse(req.url, true).query;
		(decodeURI(p.pathname)).split('/').forEach(e => {
			result += `${e}<br/>`
		});
		console.log(decodeURI(p.pathname).split('/'));
		result +=
			`pathname: ${decodeURI(p.pathname)}<br/>` +
			`search: ${p.search}<br/>`;
		for (key in q) { result += `${key} = ${q[key]}<br/>`; }

		res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
		res.end(result);
	}
}

http.createServer().listen(3000)
	.on('error', (e) => { console.log('error: ', e.code) })
	.on('request', handler);
	
	
19.	Разработка HTTP-сервера в Node.js. Обработка параметров POST-запроса. Пример. Тестирование с помощью браузера (<form>) и POSTMAN.
/*index.html*/
<html>
   <head>
    </head>
    <body>
        <div>
            <form method="POST" action="/">
                <input name="id" type="number" placeholder="id"/>
                <input name="name" type="text" placeholder="name"/>
                <input type="submit" value="OK"/>
            </form>
        </div>
    </body>
</html>


/*index.js*/
let http = require('http');
let url = require('url');
let qs = require('querystring');
let fs = require('fs');

let handler = (req, res) => {
	if (req.method == 'GET') {
		res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
		res.end(fs.readFileSync('./index.html'));
	}
	else if (req.method == 'POST') {
		let result = '';
		req.on('data', (data) => { result += data; })
		req.on('end', () => {
			result += ' <br/>';
			let o = qs.parse(result);
			for (let key in o) {
				result += `${key} = ${o[key]}<br/>`
			}
			res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
			res.end(result);
		});
	}
}

http.createServer().listen(3000)
	.on('error', (e) => { console.log('error: ', e.code) })
	.on('request', handler);


20	Разработка HTTP-сервера в Node.js. Обработка  json-сообщения в POST-запросе. Пример. Тестирование с помощью POSTMAN.

--практика
--index.js------------------------------------------
let http = require('http');

let handler = (req, res) => {
	if (req.method == 'POST') {
		let result = '';
		req.on('data', (data) => { result += data })
		req.on('end', () => {
			try {
				console.log(result)
				result = JSON.parse(result);
				res.writeHead(200, { 'Content-Type': 'application/json; charset=utf-8' });
				res.end(JSON.stringify({ result: result }));
			}
			catch (e) {
				console.log(e)
				res.end('not json')
			}
		});
	}
}

http.createServer().listen(3000)
	.on('error', (e) => { console.log('error: ', e.code) })
	.on('request', handler);



21  Разработка HTTP-сервера в Node.js. Обработка  xml-сообщения в POST-запросе. Пример. Тестирование с помощью POSTMAN.

--практика
--index.js--------------------------------------------
let http = require('http');
let parseString = require('xml2js').parseString;
let xmlbuilder = require('xmlbuilder');

let studentscalc = (obj) => {
	let rc = '<result>parse error</result>'
	try {
		let xmldoc = xmlbuilder.create('result');
		xmldoc.ele('students').att('faculty', obj.students.$.faculty).att('spec', obj.students.$.spec)
			.ele('quantity').att('value', obj.students.student.length);
		rc = xmldoc.toString({ pretty: true });
		return rc;
	} catch (e) {
		console.log(e);
		console.log('ERRROOOOOOOOOOOOOOOOOOOOOOOOOR');
		return rc
	}
}
let handler = (req, res) => {
	let xmltxt = '';
	req.on('data', (data) => { xmltxt += data })
	req.on('end', () => {
		console.log(xmltxt);
		parseString(xmltxt, (err, result) => {
			if (err) {
				res.writeHead(400);
				res.end(err);
			}
			else {
				console.log('GOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOd');
				console.log(result);
				res.writeHead(200, { 'Content-Type': 'application/xml; charset=utf-8' });
				res.write(studentscalc(result));
				res.end();
			}
		})
	})
}
http.createServer().listen(3000)
	.on('error', (e) => { console.log('error: ', e.code) })
	.on('request', handler);



22  Разработка HTTP-сервера в Node.js. Пересылка файла    в POST-запросе (upload). Пример. Тестирование с помощью браузера.

--практика
--index.html-------------------------------------------------
<html>
   <head>
    </head>
    <body>
        <div>
				<form  action='/' method="post" enctype="multipart/form-data">
					 <input type="number" name="id" />
                <input type="file" name="file">
                <input type="submit" value="load">
            </form>            
        </div>
    </body>
</html>

--index.js----------------------------------------------------
let http = require('http');
let fs = require('fs');
var multiparty = require('multiparty');
var util = require('util');
//easy way
// let handler = (req, res) => {
// 	if (req.method == 'GET') {
// 		res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
// 		res.end(fs.readFileSync('./index.html'));
// 	}
// 	else if (req.method == 'POST') {
// 		let result = '';
// 		req.on('data', data => { result += data; });
// 		req.on('end', () => {
// 			res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
// 			res.write('<H1>Uploaded</H1>');
// 			res.end(result);
// 		});
// 	}
// }

//hard way
let handler = (req, res) => {
	if (req.method === 'GET') {
		res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
		res.end(fs.readFileSync('./index.html'));
	}
	else if (req.method == 'POST') {
		console.log('here');
		let result = '';
		let form = new multiparty.Form({ uploadDir: './upload' })
		form.on('field', (name, value) => {
			console.log('----field---');
			console.log(name, value);
			result += `<br>----${name} = ${value}`;
		});
		form.on('file', (name, file) => {
			console.log('----file---');
			console.log(name, file);
			result += `<br>----${name} = ${file.originalFilename}: ${file.path}`;
		});
		form.on('error', () => {
			console.log('----err---');
			res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
			res.end('error');
		});
		form.on('close', () => {
			console.log('----close---');
			res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
			res.end(result);
		});
		form.parse(req);
	}
}

http.createServer().listen(3000)
	.on('error', (e) => { console.log('error: ', e.code) })
	.on('request', handler);


23 	Разработка HTTP-сервера в Node.js. Пересылка файла в ответе (download). Пример. Тестирование с помощью браузера.

--практика
--index.js---------------------------------------------------------
let http = require('http');
let fs = require('fs');

let handler = (req, res) => {
	if (req.url === '/' && req.method == 'GET') {
		res.writeHead(200, {
			'Content-Type': 'text/plain; charset=utf-8',
			'Content-Disposition': 'attachment; filename="file.txt"'
		});
		fs.createReadStream('./file.txt').pipe(res);
	}
	else {
		res.writeHead(200, {
			'Content-Type': 'text/plain; charset=utf-8',
			'Content-Disposition': 'attachment; filename="pic.png"'
		});
		fs.createReadStream('./pic.png').pipe(res);
	}
}

http.createServer().listen(3000)
	.on('error', (e) => { console.log('error: ', e.code) })
	.on('request', handler);


24 	Разработка HTTP-клиента в Node.js.  Оправка GET запроса с query-параметрами.  Пример. Тестирование с помощью с Node.js-сервера. 

--практика
--client.js--------------------------------------------------
var http = require("http");
var query = require("querystring");

var params = query.stringify({ x: 8, y: 4 });
var path = `/?${params}`;

var options = {
	host: "localhost",
	path: path,
	port: 3000,
	method: "GET"
};
const req = http.request(options, (res) => {
	let data = "";
	res.on("data", (chunk) => {
		data += chunk.toString("utf-8")
	});
	res.on("end", () => { console.log("end: ", data); });
});

req.on("error", (e) => { console.log("error: ", e.message); });
req.end();

--index.js--------------------------------------------------------
var http = require("http");
var url = require("url");

http.createServer((req, res) => {
	if (req.method == "GET") {
		res.statusCode = 200;
		res.end(url.parse(req.url, true).query.x + " " + url.parse(req.url, true).query.y);
	}
}).listen(3000);

25  Разработка HTTP-клиента в Node.js.  Оправка POST-запроса с параметрами в теле.  Пример. Тестирование с помощью с Node.js-сервера.

--практика
--client-------------------------------------------------------
const http = require('http')
const query = require('querystring')

const params = query.stringify({ x: 3, y: 4, s: 'xxx' })
console.log(params)
const options = {
	host: 'localhost',
	path: '/mypath',
	port: 3000,
	method: 'POST'
}
const req = http.request(options, (res) => {
	let data = ' ';

	res.on('data', (chunk) => {
		console.log('http.request: data: body =', data += chunk);
	});

	res.on('end', () => {
		console.log('http request: end: body =', data);
	})

})
req.on('error', (e) => {
	console.log('http.request: error', e.message);
})

req.write(params)

req.end();

--server------------------------------------------------------------
let http = require("http");
const query = require('querystring')

http.createServer((req, res) => {
	if (req.method == "POST") {
		res.statusCode = 200;
		let data = "";
		req.on("data", (chunk) => {
			data += chunk;
		});
		req.on("end", () => {
			console.log(query.parse(data));
			res.writeHead(200, { "Content-Type": "application/json" })
			res.end(data);
		});
	}
}).listen(3000);


26  Разработка HTTP-клиента в Node.js.  Оправка POST-запроса с json-сообщением.  Пример. Тестирование с помощью с Node.js-сервера.

--практика
--client---------------------------------------------------------------------
const http = require('http')

const params = JSON.stringify({ x: 3, y: 4, s: 'xxx' })
console.log(params)
const options = {
	host: 'localhost',
	path: '/mypath',
	port: 3000,
	method: 'POST',
	headers: {
		"Content-Type": "application/json", "accept": "application/json"
	}
}
const req = http.request(options, (res) => {
	let data = ' ';

	res.on('data', (chunk) => {
		console.log('http.request: data: body =', data += chunk);
	});

	res.on('end', () => {
		console.log('http request: end: body =', data);
		console.log('http request: end: parse(body) =', JSON.parse(data));
	})

})
req.on('error', (e) => {
	console.log('http.request: error', e.message);
})

req.write(params)

req.end();

--server-------------------------------------------------
let http = require("http");

http.createServer((req, res) => {
	if (req.method == "POST") {
		res.statusCode = 200;
		let data = "";
		req.on("data", (chunk) => {
			data += chunk;
		});
		req.on("end", () => {
			console.log(JSON.parse(data));
			res.writeHead(200, { "Content-Type": "application/json" })
			res.end(data);
		});
	}
}).listen(3000);


27  Разработка HTTP-клиента в Node.js. Обработка json-ответа. Пример. Тестирование с помощью с Node.js-сервера

--практика
--client----------------------------------------------------- 
const http = require('http')

const params = JSON.stringify({ x: 3, y: 4, s: 'xxx' })
console.log(params)
const options = {
	host: 'localhost',
	path: '/mypath',
	port: 3000,
	method: 'POST',
	headers: {
		"Content-Type": "application/json", "accept": "application/json"
	}
}
const req = http.request(options, (res) => {
	let data = ' ';

	res.on('data', (chunk) => {
		console.log('http.request: data: body =', data += chunk);
	});

	res.on('end', () => {
		console.log('http request: end: body =', data);
		const jsonResponse = JSON.parse(data);
		console.log(`http request: end: x = ${jsonResponse.x} y = ${jsonResponse.y} s = ${jsonResponse.s}`);
	})

})
req.on('error', (e) => {
	console.log('http.request: error', e.message);
})

req.write(params)

req.end();

--server-------------------------------------------------------
let http = require("http");

http.createServer((req, res) => {
	if (req.method == "POST") {
		res.statusCode = 200;
		let data = "";
		req.on("data", (chunk) => {
			data += chunk;
		});
		req.on("end", () => {
			console.log(JSON.parse(data));
			res.writeHead(200, { "Content-Type": "application/json" })
			res.end(data);
		});
	}
}).listen(3000);
28.  Разработка HTTP-клиента в Node.js. Обработка xml-ответа. Пример. Тестирование с помощью с Node.js-сервера.

-------------------------server.js-------------------------

const http = require('http');
const parseString = require('xml2js').parseString;
http.createServer((request, response) => {
	let data = '';
	request.on('data', (chunk) => {
		data += chunk
	})
	request.on('end', () => {
		parseString(data, (err, str) => {
			if (err) {
				response.writeHead(400, { 'Content-Type': 'text/xml' });
				response.end(data);
				console.log('xml parse error');
			}
			else {
				console.log('str: ', str);
				console.log('str.result: ', str.result);
				response.writeHead(200, { 'Content-Type': 'text/xml' });
				response.end(data);
			}
		})
	})
}).listen(3000);

console.log('Server running at http://127.0.0.1:3000/');

-------------------------client.js-------------------------

const http = require('http');
const parseString = require('xml2js').parseString;
const xmlbuilder = require('xmlbuilder')

let xmldoc = xmlbuilder.create('students').att('faculty', 'ИТ').att('spec', 'ИСиТ');
xmldoc.ele('student').att('id', '1').att('name', 'pet9')
	.up().ele('student').att('id', '2').att('name', 'vas9').txt('Прошел в itechart')
	.up().ele('student').att('id', '3').att('name', 'san9')

const options = {
	host: 'localhost',
	path: '/mypath',
	port: 3000,
	method: 'POST',
	headers: {
		"Content-Type": "text/xml", "accept": "text/xml"
	}
}

const req = http.request(options, (res) => {
	let data = '';
	res.on('data', (chunk) => {
		data += chunk;
	})
	res.on('end', () => {
		console.log(data);
		parseString(data, (err, str) => {
			if (err)
				console.log('xml parse error');
			else {
				console.log('str: ', str);
				console.log('str.result: ', str.result);
			}
		})
	})
})
req.write(xmldoc.toString({ pretty: true }))
req.end();

29.  Разработка HTTP-клиента в Node.js.  Пересылка файла на сервер в POST-запросе (upload).   Пример. Тестирование с помощью с Node.js-сервера.

-------------------------server.js-------------------------

let http = require('http');

let handler = (req, res) => {
	let data = ''
	req.on('data', (chunk) => {
		data += chunk;
	});
	req.on('end', () => {
		res.end(data);
	})
}

http.createServer().listen(3000)
	.on('request', handler);
console.log("start")

let http = require('http');

let handler = (req, res) => {
	let data = ''
	req.on('data', (chunk) => {
		data += chunk;
	});
	req.on('end', () => {
		res.end(data);
	})
}

http.createServer().listen(3000)
	.on('request', handler);
console.log("start")

-------------------------client1.js-------------------------

const http = require('http');
const fs = require('fs');
let bound = 'smw60-smw60-smw60';
let body = `--${bound}\n`;
body += 'Content-Disposition: form-data; name="file"; filename="file.txt" \n';
body += 'Content-Type: text/plain\n\n';
body += fs.readFileSync('./from/file.txt');
body += `\n--${bound}--\n`

let options = {
	host: 'localhost',
	path: '/mypath',
	port: 3000,
	method: 'POST',
	headers: {
		'content-type': 'multipart/form-data; boundary=' + bound
	}
}

const req = http.request(options, (res) => {

	let data = '';
	res.on('data', (chunk) => {
		console.log('http.request: data: body = ', data += chunk.toString('utf8'));
	})
	res.on('end', () => {
		console.log('http.request: end: body=', data)
	})
})
req.on('error', (e) => {
	console.log('http.request: error:', e.message)
})
req.end(body);


-------------------------client2.js-------------------------

const http = require('http');
const fs = require('fs');
let bound = 'smw60-smw60-smw60';
let body = `--${bound}\n`;
body += 'Content-Disposition: form-data; name="file"; filename="file.bmp" \n';
body += 'Content-Type: application/octet-stream\n\n';


let options = {
	host: 'localhost',
	path: '/mypath',
	port: 3000,
	method: 'POST',
	headers: {
		'content-type': 'multipart/form-data; boundary=' + bound
	}
}

const req = http.request(options, (res) => {

	let data = '';
	res.on('data', (chunk) => {
		data += chunk;
	})
	res.on('end', () => {
		console.log('http.request: end: lentgth body=', Buffer.byteLength(data))
	})
})

req.on('error', (e) => {
	console.log('http.request: error:', e.message)
})

req.write(body);

let stream = new fs.ReadStream('./from/pic.bmp')

stream.on('data', (chunk) => {
	req.write(chunk)
	console.log(Buffer.byteLength(chunk));
})
stream.on('end', () => {
	req.end(`\n--${bound}--`)
})

30.  Разработка HTTP-клиента в Node.js. Обработка ответа с файлом (download). Пример. Тестирование с помощью с Node.js-сервера. 

-------------------------server.js-------------------------

const http = require('http');
const fs = require('fs');
http.createServer(function (request, response) {
	fs.access(__dirname + request.url, fs.constants.R_OK, (err) => {
		if (err) {
			response.statusCode = 200;
			console.log(err)
			response.end('Error');
		}
		else {
			fs.createReadStream(__dirname + request.url).pipe(response);
		}
	})
}).listen(3000);

console.log('Server running at http://127.0.0.1:3000/');

-------------------------client.js-------------------------

const http = require('http');
const fs = require('fs');

const file = fs.createWriteStream('./to/file.bmp');

let options = {
	host: 'localhost',
	path: '/from/pic.bmp',
	port: 3000,
	method: 'GET'
}

const req = http.request(options, (res) => {
	res.pipe(file);
})

req.on('error', (e) => {
	console.log('http.req: error', e.message)
})
req.end();

31.  Разработка Websockets-приложения: Node.js-сервер, браузер-клиент. Пример.

-------------------------index.js-------------------------

const http = require('http');
const WebSocket = require('ws');
const fs = require('fs');

http.createServer((req, res) => {
	if (req.method == 'GET') {
		res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
		res.end(fs.readFileSync('./index.html'));
	}
	else {
		res.statusCode = 405;
		res.end();
	}
}).listen(3000);

let k = 0;
const wsserver = new WebSocket.Server({ port: 4000, host: 'localhost', path: '/ws' });
wsserver.on('connection', (wss) => {
	wss.on('message', message => {
		console.log(`Received message => ${message}`);
	})
	setInterval(() => { wss.send(`server: ${++k}`) }, 5000);
})
wsserver.on('error', (e) => { console.log('ws server error', e) });
console.log(`ws server: host:${wsserver.options.host}, port:${wsserver.options.port}, path:${wsserver.options.path}`);

-------------------------index.html-------------------------

<html>
    <head></head>
    <body>
        <script>
			  let socket = new WebSocket('ws://localhost:4000/ws');
			  socket.onopen = () => {
                socket.send('hi');
                console.log('open ws');
            }
            socket.onerror = (e) => {console.log('error '+e.message)}
            socket.onmessage = (msg)=> {console.log('message '+msg.data)}
            socket.onclose = (msg)=>{console.log('close '+msg.code)}
        </script>
    </body>
</html>

32.  Разработка широковещательного Websockets-приложения: Node.js-сервер, Node.js-клиент. Пример.

-------------------------index.js-------------------------

const WebSocket = require('ws')

const wss = new WebSocket.Server({ port: 5000, host: 'localhost', path: '/broadcast' });

wss.on('connection', (ws) => {
	ws.on('message', data => {
		wss.clients.forEach((client) => {
			if (client.readyState === WebSocket.OPEN)
				client.send('server: ' + data);
		})
	})
})

-------------------------client.js-------------------------

const WebSocket = require('ws');

const ws = new WebSocket('ws://localhost:5000/broadcast');

let parm = process.argv[2]

let prfx = !parm ? 'A' : parm

ws.on('open', () => {
	setInterval(() => {
		ws.send('client: ' + prfx);
	}, 1000);
	ws.on('message', message => {
		console.log(`Recevied message => ${message}`)
	})
	setTimeout(() => {
		ws.close()
	}, 15000)
})

33.  Разработка Websockets-приложения: Node.js-сервер с применением потока, Node.js-клиент.

-------------------------index.js-------------------------

const WebSocket = require('ws')

const wss = new WebSocket.Server({ port: 5000, host: 'localhost', path: '/server' });

wss.on('connection', (ws) => {
	const duplex = WebSocket.createWebSocketStream(ws, { encoding: 'utf8' })

	duplex.pipe(process.stdout) // от сервера 

	process.stdin.pipe(duplex); // серверу

})

-------------------------client.js-------------------------

const WebSocket = require('ws')

const ws = new WebSocket('ws://localhost:5000/server')

const duplex = WebSocket.createWebSocketStream(ws, { encoding: 'utf8' })

duplex.pipe(process.stdout) // от сервера 

process.stdin.pipe(duplex); // серверу

34.  Разработка Websockets-приложения:  ping/pong-сообщения, Node.js-сервер, Node.js-клиент.

-------------------------server.js-------------------------

const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 5000, host: 'localhost' })

wss.on('connection', ws => {
	ws.ping('ping from server');
	ws.on('ping', (data) => {
		console.log(data.toString('utf8'));
		ws.pong('pong from server');
	})
	ws.on('pong', (data) => {
		console.log(data.toString('utf-8'))
	})
})

-------------------------client.js-------------------------

const WebSocket = require('ws')

const ws = new WebSocket('ws://localhost:5000/server')

ws.on('open', () => {
	ws.ping('ping from client');
	ws.on('ping', (data) => {
		console.log(data.toString('utf-8'))
		ws.pong('pong from client');
	})
	ws.on('pong', (data) => {
		console.log(data.toString('utf-8'))
	})
})
35.	Разработка Websockets-приложения:  обработка json-сообщений, Node.js-сервер, Node.js-клиент. Пример.
-----------------server--------------------------------------------
const WebSocket = require('ws');


const ws = new WebSocket.Server({ port: 5000, host: 'localhost', path: '/ws' });
ws.on('connection', (wss) => {
	let k = 0;
	wss.on('message', message => {
		console.log(`Received message => client: ${message}`);
	})
	setInterval(() => { wss.send(JSON.stringify({ msg: ++k })) }, 3000);
})
------------------client--------------------------------------
const WebSocket = require('ws');
const ws = new WebSocket('ws://localhost:5000/ws');

ws.on('open', () => {
	ws.on('message', message => {
		console.log(`Received message => ${message}`)
		message = JSON.parse(message).msg;
		ws.send(message);
	})
	setTimeout(() => { ws.close() }, 25000);
});

36.	Разработка Websockets-приложения: отправка клиентом файла (upload), Node.js-сервер, Node.js-клиент. Пример.

-----------------server--------------------------------------------
const WebSocket = require('ws')
const fs = require('fs')
const wss = new WebSocket.Server({ port: 5001, host: 'localhost', path: '/server' });
let k = 0;
wss.on('connection', (ws) => {
	const duplex = WebSocket.createWebSocketStream(ws, { encoding: 'utf8' })
	let wfile = fs.createWriteStream(`./file${++k}.txt`)
	duplex.pipe(wfile)
})
------------------client--------------------------------------
const WebSocket = require('ws')
const fs = require('fs')
const ws = new WebSocket('ws://localhost:5001/server')
ws.on('open', () => {
	const duplex = WebSocket.createWebSocketStream(ws, { encoding: 'utf8' })
	let rfile = fs.createReadStream(`./MyFile.txt`)
	rfile.pipe(duplex);
})





37.	Разработка Websockets-приложения: отправка  сервером файла (download), Node.js-сервер, Node.js-клиент. Пример.

-----------------server--------------------------------------------
const WebSocket = require('ws')
const fs = require('fs')
const wss = new WebSocket.Server({ port: 5001, host: 'localhost', path: '/server' });

wss.on('connection', (ws) => {
	const duplex = WebSocket.createWebSocketStream(ws, { encoding: 'utf8' })
	let rfile = fs.createReadStream(`./MyFile.txt`)
	rfile.pipe(duplex);
})


------------------client--------------------------------------
const WebSocket = require('ws')
const fs = require('fs')
const ws = new WebSocket('ws://localhost:5001/server')
let k = 0;
ws.on('open', () => {
	const duplex = WebSocket.createWebSocketStream(ws, { encoding: 'utf8' })
	let wfile = fs.createWriteStream(`./file${++k}.txt`)
	duplex.pipe(wfile)
})





38.	Разработка  RPC-Websockets-сервера. Пример. Тестирование:  Node.js-клиент. 


-----------------server--------------------------------------------
const WebSocketServer = require('rpc-websockets').Server

const server = new WebSocketServer({
	port: 3000,
	host: 'localhost'
})

server.setAuth((l) => l.login === 'login' && l.password === 'password')

server.register('sum', function (params) {
	return params[0] + params[1]
})

server.register('account', () => {
	return 'account'
}).protected()

// server.event('feedUpdated')

//console.log(server.eventList())

setInterval(() => server.emit('feedUpdated'), 3000);


------------------client--------------------------------------
var WebSocket = require('rpc-websockets').Client
let ws = new WebSocket('ws://localhost:3000')

ws.on('open', function () {
	ws.call('sum', [5, 3]).then(function (result) {
		console.log(result);
	})
	// ws.subscribe('feedUpdated')

	// ws.on('feedUpdated', function () {
	// 	console.log('feedUpdated')
	// })

	ws.login({ 'login': 'login', 'password': 'password' }).then((login) => {
		ws.call('account').then(function (result) {
			console.log(result)
		})
	}).catch(function (error) {
		console.log('auth failed')
	})
})











39.	Разработка  RPC-Websockets-сервера: обработка уведомлений. Пример. Тестирование:  Node.js-клиент.




-----------------server--------------------------------------------

const WebSocketServer = require('rpc-websockets').Server
const server = new WebSocketServer({
	port: 3000,
	host: 'localhost'
})
server.register('notify1', (obj) => {
	console.log(obj);
})
------------------client--------------------------------------
var WebSocket = require('rpc-websockets').Client
let ws = new WebSocket('ws://localhost:3000')
ws.on('open', function () {
	ws.notify('notify1', { data: 'client' });
})









40.	Работа с файловой системой в Node.js: создание, копирование, проверка существования файла, запись, запись в конец, чтение, синхронные асинхронные операции. Пример.

fs = require('fs')

fs.open('new.txt', 'w', (e, file) => {
    if(e) throw e;
    console.log('файл создан');
})

fs.copyFile('new.txt', 'newCopy.txt', (e)=>{
    if(e) console.log(e);
    console.log('копия создана');
})

fs.exists('new.txt', (exists) =>{
    if(exists) console.log('есть')
    else console.log('нет')
})
//это асинхронно
fs.writeFile('new.txt', 'qqq', (e)=>{
    if(e) throw e;
    console.log('запись успешна');
})
//это тоже асинхронно
fs.appendFile('new.txt', 'www', (e)=>{
    if(e) throw e;
    console.log('добавление успешно');
})

fs.readFile('new.txt', (e,data)=>{
    if(e) console.log('Ошибка ', e)
    else console.log('data: ', data.toString('utf8'))
})


---------------------------------------------------------------------------------------------














41.	Работа с файловой системой в Node.js: создание, удаление, переименование, запись, запись в конец, чтение, синхронные асинхронные операции. Пример.



fs = require('fs')


fs.unlink('new.txt', (e)=>{
    if(e) console.log('Ошибка: ', e);
    else  console.log('Файл удалён')
})

fs.open('new.txt', 'w', (e, file) => {
    if(e) throw e;
    console.log('файл создан');
})

//это асинхронно
fs.writeFile('new.txt', 'qqq', (e)=>{
    if(e) throw e;
    console.log('запись успешна');
})
//это тоже асинхронно
fs.appendFile('new.txt', 'www', (e)=>{
    if(e) throw e;
    console.log('добавление успешно');
})

fs.readFile('new.txt', (e,data)=>{
    if(e) console.log('Ошибка ', e)
    else console.log('data: ', data.toString('utf8'))
})

fs.rename('new.txt', 'newReName.txt',(e)=>{
    if(e) throw e;
    console.log('переименование успешно');
})

---------------------------------------------------------------------------------------------
42.	Работа с файловой системой в Node.js: создание, слежение за файлом, запись, запись в конец, чтение, синхронные асинхронные операции. Пример.

fs = require('fs')

fs.open('new.txt', 'w', (e, file) => {
    if(e) throw e;
    console.log('файл создан');
})

try {
    fs.watch('new.txt', (event, filename) =>{
        if(filename) console.log(`folder: ${filename}, event: ${event}`)
    })
}
catch (e){
    console.log('e = ', e)
}
//это асинхронно
fs.writeFile('new.txt', 'qqq', (e)=>{
    if(e) throw e;
    console.log('запись успешна');
})
//это тоже асинхронно
fs.appendFile('new.txt', 'www', (e)=>{
    if(e) throw e;
    console.log('добавление успешно');
})

fs.readFile('new.txt', (e,data)=>{
    if(e) console.log('Ошибка ', e)
    else console.log('data: ', data.toString('utf8'))
})


43.	Работа с файловой системой в Node.js: запись в файл потока октетов, чтение из файла потока октетов. Пример.

fs = require('fs')

let wbuf = Buffer.from([1,2,4,8,254])
fs.writeFile('new.dat', wbuf, (e)=>{
    if(e) throw e;
    console.log('запись успешна')
})

fs.readFile('new.dat', (e,data)=>{
    if(e) {console.log('Ошибка ', e)}
    else {
        let array = [];
        for (data of data.values())
            array.push(data);
        console.log(array);
    }
})


44.	Работа с файловой системой в Node.js: запись в файл  массива 32-битовых целочисленных данных, чтение из файла массива 32-битовых целочисленных данных. Пример.

fs = require('fs')

let k = 5; //количество чисел
let sizeInt32LE = 4; // размер Int32
let wbuf = Buffer.allocUnsafe(sizeInt32LE * k) //выделяем 40 байт

fs.open('new.dat', 'w', (e, file)=>{
    for(let i=0; i<k;i++) wbuf.writeInt32LE(i, i*sizeInt32LE);
    fs.writeFile(file, wbuf, (e)=> {
        if(e) throw e;
        console.log("записано")
    })
})


fs.readFile('new.dat', (e,buf)=> {
    if(e) throw e;
    else {
        let k = buf.length / sizeInt32LE; // количество чисел
        let m = [];
        for(let i=0; i<k;i++) m.push(buf.readInt32LE(i*sizeInt32LE));
        console.log(m)
    }
})


45.	Применение потокового чтение (Readable) и записи (Writable) файлов в Node.js.  Пример.

fs = require('fs')
let data = '';

const writerStream = fs.createWriteStream('file.txt');
data = 'qqqq2qqqqq';
writerStream.write(data,'UTF8');
writerStream.end();

///////////////////////////////////////
let dataRead = "";
const readerStream = fs.createReadStream('file.txt');
readerStream.setEncoding('UTF8');
readerStream.on('data', function(chunk) {
    dataRead += chunk;
});
readerStream.on('end',function(){
    console.log(data);
});

46.	Применение функции pipe для обработки данных (файла) запроса и записи в файл файловой системы. Пример.

CLIENT:

let http = require('http');
let fs = require('fs');
let options = {
    host: 'localhost',
    path: '/',
    method: 'POST',
    port: 3000,
};
let req = http.request(options, (res) => {
    console.log('here')
});

let rs = new fs.createReadStream('./file.txt');

rs.pipe(req)

SERVER:


let http = require('http');
const fs = require('fs')

let handler = (req, res) => {

    const ws = fs.createWriteStream('./new.txt')

    req.pipe(ws);
}

http.createServer().listen(3000)
    .on('request', handler);
console.log("start")


47.	Применение функции pipe для обработки данных (файла) файловой системы и записи в http-ответ. Пример.

let http = require('http');
let fs = require('fs');
//Pipe - это канал, который связывает поток
//для чтения и поток для записи и позволяет сразу
//считать из потока чтения в поток записи.

//http://localhost:3000
let handler = (req, res)=>{
    if(req.method == 'GET') {
        res.writeHead(200, {
            'Content-Type': 'text/plain; charset=utf-8',
            'Content-Disposition': 'form-data; filename="file.txt"'
        });
        fs.createReadStream('./file.txt').pipe(res);
    }
}

http.createServer().listen(3000)
    .on('error', (e)=>{console.log('error: ', e.code)})
    .on('request', handler);


48.	Разработка клиент-серверного TCP-приложения: обмен текстовыми сообщениями. Пример.

CLIENT:

const net = require('net');

let HOST = 'localhost';
let PORT = 4000;

let client = new net.Socket();
client.connect(PORT, HOST, () => {
    console.log(`Client connected: ${client.remoteAddress}:${client.remotePort}`);
});

client.write('Message for Server');

client.on('data', data => {
    console.log(`Client data: ${data.toString()}`);
    client.destroy();
});

client.on('close', () => {
    console.log('Client closed');
});

client.on('error', (e) => {
    console.log('Client error: ', e);
});

SERVER:

const net = require('net');

let HOST = 'localhost';
let PORT = 4000;

net.createServer((sock) => {
    sock.on('error', (e) => {
        console.log(`Server error: ${e}`);
    });

    console.log(`Server connected: ${sock.remoteAddress}:${sock.remotePort}`);

    sock.on('data', (data) => {
        console.log(`Server data: ${data.toString()}`);
        sock.write(`Echo=> ${data}`);
    });

    sock.on('close', data => {
        console.log("Server closed");
    });
}).listen(PORT, HOST);
49.  Разработка клиент-серверного TCP-приложения: пересылка массива целочисленных данных.

-------------------------server.js-------------------------

const net = require('net');

let HOST = '0.0.0.0';
let PORT = 4000;


let Server = net.createServer();
Server.on('connection', (sock) => {
	console.log(`Server connected: ${sock.remoteAddress}:${sock.remotePort}`);

	sock.on('data', (data) => {
		let array = [];
		for (data of data.values())
			array.push(data);
		console.log(array);
	});


	sock.on('close', data => {
		console.log("Server closed");
	});

	sock.on('error', (e) => {
		console.log(`Server error: ${e}`);
	});

});

Server.on('listening', () => {
	console.log(`Server connected: ${HOST}:${PORT}`);
});
Server.on('error', (e) => {
	console.log(`TCP-Server error: ${e}`);
});

Server.listen(PORT, HOST);

-------------------------client.js-------------------------

const net = require('net');

let HOST = '127.0.0.1';
let PORT = 4000;

let client = new net.Socket();
let buf =  Buffer.from([122313,2,3])
client.connect(PORT, HOST, () => {
    console.log(`Client connected: ${client.remoteAddress}:${client.remotePort}`);

    client.write((buf));
});

client.on('close', () => {
    console.log('Client closed');
});

client.on('error', (e) => {
    console.log('Client error: ', e);
});

50.  Разработка клиент-серверного TCP-приложения: пересылка файла от клиента серверу.

-------------------------server.js-------------------------

const net = require('net');

let HOST = '0.0.0.0';
let PORT = 4000;

let ws = require('fs').createWriteStream('./new/new.txt');

let Server = net.createServer();
Server.on('connection', (sock) => {
    console.log(`Server connected: ${sock.remoteAddress}:${sock.remotePort}`);

    sock.pipe(ws);

    sock.on('close', data => {
        console.log("Server closed");
    });

    sock.on('error', (e) => {
        console.log(`Server error: ${e}`);
    });

});

Server.on('listening', () => {
    console.log(`Server connected: ${HOST}:${PORT}`);
});
Server.on('error', (e) => {
    console.log(`TCP-Server error: ${e}`);
});

Server.listen(PORT, HOST);

-------------------------client.js-------------------------

const net = require('net');

let HOST = '127.0.0.1';
let PORT = 4000;

let ws = require('fs').createReadStream('./old/old.txt');

let client = new net.Socket();
client.connect(PORT, HOST, () => {
    console.log(`Client connected: ${client.remoteAddress}:${client.remotePort}`);
    ws.pipe(client);
});

client.on('close', () => {
    console.log('Client closed');
});

client.on('error', (e) => {
    console.log('Client error: ', e);
});

51.  Разработка клиент-серверного TCP-приложения: пересылка файла от сервера клиенту.

-------------------------server.js-------------------------

const net = require('net');

let HOST = '0.0.0.0';
let PORT = 4000;

let ws = require('fs').createReadStream('./old/old.txt');
let Server = net.createServer();
Server.on('connection', (sock) => {
	console.log(`Server connected: ${sock.remoteAddress}:${sock.remotePort}`);
	ws.pipe(sock);
	sock.on('close', data => {
		console.log("Server closed");
	});

	sock.on('error', (e) => {
		console.log(`Server error: ${e}`);
	});

});

Server.on('listening', () => {
	console.log(`Server connected: ${HOST}:${PORT}`);
});
Server.on('error', (e) => {
	console.log(`TCP-Server error: ${e}`);
});

Server.listen(PORT, HOST);

-------------------------client.js-------------------------

const net = require('net');

let HOST = '127.0.0.1';
let PORT = 4000;

let ws = require('fs').createWriteStream('./new/new.txt');

let client = new net.Socket();
client.connect(PORT, HOST, () => {
	console.log(`Client connected: ${client.remoteAddress}:${client.remotePort}`);
	client.pipe(ws);
});

client.on('close', () => {
	console.log('Client closed');
});

client.on('error', (e) => {
	console.log('Client error: ', e);
});

52.  Разработка клиент-серверного TCP-приложения прослушивающего два порта, обмен текстовыми сообщениями.

-------------------------server.js-------------------------

const net = require('net');

let HOST = '0.0.0.0';
let PORT_O = 4000;
let PORT_S = 5000;


net.createServer((Server) => ServerStart(Server)).listen(PORT_O, HOST);
net.createServer((Server) => ServerStart(Server)).listen(PORT_S, HOST);

function ServerStart(sock) {
    console.log(`Server connected: ${sock.remoteAddress}:${sock.remotePort}`);
    sock.on('error', (e) => {
        console.log(`Server error: ${e}`);
    });


    let input = process.stdin;
    input.on('data', data => {
        sock.write(data);
    });

    sock.on('data', (data) => {
        console.log(data.toString());
    });
}

-------------------------client1.js-------------------------

const net = require('net');

let HOST = '127.0.0.1';
let PORT = 4000;

let client = new net.Socket();

client.connect(PORT, HOST, () => {
    console.log(`Client connected: ${client.remoteAddress}:${client.remotePort}`);

    let input = process.stdin;
    input.on('data', data => {
            client.write(data);
    });

    client.on('data', (data) => {
        console.log(data.toString());
    });
});


client.on('data', data => {
    console.log(`Client data: ${data.toString()}`);
});

client.on('close', () => {
    console.log('Client closed');
});

client.on('error', (e) => {
    console.log('Client error: ', e);
});

-------------------------client2.js-------------------------

const net = require('net');

let HOST = '127.0.0.1';
let PORT = 5000;

let client = new net.Socket();

client.connect(PORT, HOST, () => {
    console.log(`Client connected: ${client.remoteAddress}:${client.remotePort}`);

    let input = process.stdin;
    input.on('data', data => {
        client.write(data);
    });

    client.on('data', (data) => {
        console.log(data.toString());
    });
});


client.on('data', data => {
    console.log(`Client data: ${data.toString()}`);
});

client.on('close', () => {
    console.log('Client closed');
});

client.on('error', (e) => {
    console.log('Client error: ', e);
});

53.  Разработка клиент-серверного UDP-приложения: обмен текстовыми сообщениями.

-------------------------server.js-------------------------

const udp = require('dgram');

const PORT = 4000;
let server = udp.createSocket('udp4')

server.on('message', (msg, info) => {
    let MsgBuff = msg.toString();

    console.log(MsgBuff);
    MsgBuff = `ECHO:${MsgBuff}`;

    server.send(MsgBuff, info.port, info.address, (err) => {
        if (err) server.close();
        else console.log('Sended');
    });
})

    .on('close', () => console.log('Server CLOSED'))
    .on('error', (err) => {
        console.log('Error: ' + err);
        server.close();
    });

server.bind(PORT);

-------------------------client.js-------------------------

const udp = require('dgram');


const PORT = 4000;
let client = udp.createSocket('udp4')

client.on('message', (msg, info) => {
    MsgBuff = msg.toString();
    console.log(MsgBuff);
})
    .on('error', (err) => {
        console.log('Error: ' + err);
        client.close();
    });


client.send('HI', PORT, 'localhost', (err) => {
    if (err) client.close();
    else console.log('Sended');
});

54.  Разработка приложения, выполняющего запрос к SQL-базе данных: выполнение динамического SELECT-запроса.

-------------------------DB.js-------------------------

const sql = require('mssql')
var config = {
	user: 'Vad',
	password: 'Vad',
	server: 'localhost',
	database: 'GVA',
	"options": {
		"encrypt": true,
		"enableArithAbort": true
	}
};

class DataBase {
	constructor() {
		this.connectionPool = new sql.ConnectionPool(config).connect().then(pool => {
			console.log('Connected to MSSQL')
			return pool
		}).catch(err => console.log('Connection Failed: ', err));
	}
	get_Faculties(faculty) {
		return this.connectionPool.then(pool => pool.request()
			.input('faculty', sql.NVarChar, faculty)
			.query('Select * FROM FACULTY Where FACULTY = @faculty'))
	}
}
module.exports = DataBase;

-------------------------index.js-------------------------

const DB = require('./DB');
const http = require('http');
const url = require('url');
const Db = new DB();

let GET_handler = (req, res) => {
    switch (url.parse(req.url).pathname) {
        case '/faculties':
            let faculty = url.parse(req.url, true).query.faculty;
            //console.log(faculty)
            Db.get_Faculties(faculty).then(records => {
                res.statusCode = 200;
                res.setHeader('Content-Type', 'application/json');
                res.setHeader('Access-Control-Allow-Origin', '*');
                res.setHeader('Access-Control-Allow-Headers', '*');
                res.end(JSON.stringify(records.recordset))
            }).catch(error => {
                res.statusCode = 400;
                res.statusMessage = 'Invalid method';
                res.end(JSON.stringify({error: String(error)}));
            });
            break;
        default:
            break;
    }
}

let http_handler = (req, res) => {

    console.log(req.method);
    switch (req.method) {
        case 'GET':
            GET_handler(req, res);
            break;
        default:
            break;
    }
}

//http://localhost:3002/faculties?faculty=<faculty_name>
let server = http.createServer();
server.listen(3002, () => {
    console.log('server.listen(3002)')
}).on('request', http_handler);

55.  Разработка приложения, выполняющего запрос к SQL-базе данных: выполнение динамического INSERT-запроса.

-------------------------DB.js-------------------------

const sql = require('mssql')
var config = {
    user: 'Vad',
    password: 'Vad',
    server: 'localhost',
    database: 'GVA',
    "options": {
        "encrypt": true,
        "enableArithAbort": true
    }
};

class DataBase {
    constructor() {
        this.connectionPool = new sql.ConnectionPool(config).connect().then(pool => {
            console.log('Connected to MSSQL')
            return pool
        }).catch(err => console.log('Connection Failed: ', err));
    }
    post_Faculties(faculty, faculty_name){
        return this.connectionPool.then(pool => {
            return pool.request()
                .input('faculty', sql.NVarChar, faculty)
                .input('faculty_name', sql.NVarChar, faculty_name)
                .query('INSERT FACULTY(FACULTY, FACULTY_NAME) values(@faculty , @faculty_name)');
        });
    }
}
module.exports = DataBase;

-------------------------index.js-------------------------

const DB = require('./DB');
const http = require('http');
const url = require('url');
const Db = new DB();

let POST_handler = (req, res) => {
    switch (url.parse(req.url).pathname) {
        case '/faculties':
            let data_json = '';
            req.on('data', chunk => {
                data_json += chunk;
            });
            req.on('end', () => {
                data_json = JSON.parse(data_json);
                res.writeHead(200, {'Content-Type': 'application/json'});
                Db.post_Faculties(data_json.FACULTY, data_json.FACULTY_NAME).then(records => {
                    res.end(JSON.stringify(data_json))
                }).catch(error => {    res.statusCode = 400;
                    res.statusMessage = 'Invalid method';
                    res.end(JSON.stringify({error: String(error)}));});
            });
            break;
        default:
            break;
    }
}

let http_handler = (req, res) => {
    switch (req.method) {
        case 'POST':
            POST_handler(req, res);
            break;
        default:
            break;
    }
}

//http://localhost:3002/faculties
//BODY
//{
// "FACULTY": "www22",
// "FACULTY_NAME": "1"
// }
let server = http.createServer();
server.listen(3002, () => {
    console.log('server.listen(3002)')
}).on('request', http_handler);

56.	Разработка приложения, выполняющего запрос к SQL-базе данных: выполнение динамического UPDATE-запроса. Пример.
// index.js
const sql = require('mssql')
const config = {
	user: 'Arcuman',
	password: 'Arcuman',
	server: 'localhost',
	database: 'BAA'
}
class DB {
	constructor() {
		this.connectionPool = new sql.ConnectionPool(config).connect().then(pool => {
			console.log('Connetct to DB')
			return pool;
		}).catch(err => console.log(err))
	}
	put_Faculties(faculty, facultyName) {
		return this.connectionPool.then(pool =>
			pool.request()
				.input('faculty', sql.NVarChar, faculty)
				.input('faculty_name', sql.NVarChar, facultyName)
				.query('UPDATE FACULTY SET FACULTY_NAME = @faculty_name WHERE FACULTY = @faculty')
		)
	}
}

const db = new DB();
db.put_Faculties('AFR1', 'JDSHY1').then(res => {
	console.log(res)
});


// Другая конфигурация, если конфигурация из index не пашет
const config = {
    user: 'java',
    password: 'java',
    server: 'DESKTOP-8NQEQ1G',
    database: 'Nodejs',
    options: {
        encrypt: true,
        enableArithAbort: true,
    },
};

57.	Разработка приложения, выполняющего запрос к SQL-базе данных: выполнение динамического DELETE-запроса. Пример.

// index.js
const sql = require('mssql')
const config = {
	user: 'Arcuman',
	password: 'Arcuman',
	server: 'localhost',
	database: 'BAA'
}
class DB {
	constructor() {
		this.connectionPool = new sql.ConnectionPool(config).connect().then(pool => {
			console.log('Connetct to DB')
			return pool;
		}).catch(err => console.log(err))
	}
	deleteFaculties(faculty) {
		return this.connectionPool.then(pool =>
			pool.request()
				.input('faculty', sql.NVarChar, faculty)
				.query('DELETE FROM FACULTY WHERE FACULTY = @faculty')
		)
	}
}

const db = new DB();
db.deleteFaculties('AFR1').then(res => {
	console.log(res)
});

58.	Разработка приложения, выполняющего запрос к SQL-базе данных: вызов удаленной процедуры. Пример.
----------------------------ПРОЦЕДУРА----------------------------------
----------------------------DB.js---------------------------------------
const sql = require('mssql')
var config = {
	user: 'Arcuman',
	password: 'Arcuman',
	server: 'localhost',
	database: 'BAA',
};

class DataBase {
	constructor() {
		this.connectionPool = new sql.ConnectionPool(config).connect().then(pool => {
			console.log('Connected to MSSQL')
			return pool
		}).catch(err => console.log('Connection Failed: ', err));
	}

	countFaculty(faculty) {
		return this.connectionPool.then(pool => {
			return pool.request()
				.input('FACULTY', sql.NVarChar(40), faculty)
				.output('count', sql.Int)
				.execute('COUNT_FACULTY')
		});
	}
}

let db = new DataBase();
db.countFaculty('ХТиТ').then((res) => {
	console.log('Output Param')
	console.log(res)
	console.log(res.output.count)
})


59.	Разработка приложения, выполняющего graphql-запрос к SQL-базе данных: query-запрос. Пример.
60. Разработка приложения, выполняющего graphql-запрос к SQL-базе данных: mutation-запрос. Пример. 
--------------------------------------POSTMAN-----------------------------------------
query-запрос 
# query{getFaculties{FACULTY, FACULTY_NAME}}
# -------------------------------------------------
# query{
#      getFaculties(FACULTY:"ТОВ")
#         {FACULTY, FACULTY_NAME}
#         }
mutation-запрос
mutation{
    setFaculty
    (FACULTY: "3", FACULTY_NAME: "wwww")
    {
        FACULTY
        FACULTY_NAME
    }}
-----------------------------------index.js-------------------------------
const http = require('http');
const { graphql, buildSchema } = require('graphql');
const schema = buildSchema(require('fs').readFileSync('./schema.gql').toString());
const { DB } = require('./DB');
const resolver = require('./resolver');

const server = http.createServer();

const context = DB();

const handler = (request, response) => {
	if (request.method === 'POST') {
		let result = '';
		request.on('data', (data) => { result += data; });
		request.on('end', () => {
			let obj = JSON.parse(result);
			if (obj.query) {
				graphql(schema, obj.query, resolver, context, obj.variables ? obj.variables : {})
					.then((result) => {
						if (result.data) {
							response.writeHead(200, { 'Content-Type': 'application/json; charset=utf-8' });
							response.end(JSON.stringify(result.data));
						}
						else {
							response.writeHead(400, { 'Content-Type': 'application/json; charset=utf-8' });
							response.end(result.errors[0].message);
						}
					})
			}
		})
	}
};

server.listen(3000, () => {
	console.log('Server running at http://localhost:3000/')
})
	.on('error', (err) => { console.log('Error:', err.code); })
	.on('request', handler);

--------------------------dependencies----------------------------
"graphql": "^15.4.0",
"msnodesqlv8": "^2.0.8",
"mssql": "^6.3.0"

--------------------------------DBConfig.js---------------------------
const config = {
	driver: 'msnodesqlv8',
	connectionString: 'Driver={SQL Server Native Client 11.0};' +
		'Server={localhost};' +
		'Database={BAA};' +
		'Trusted_Connection={yes};'
};

module.exports = config;

59- Разработка приложения, выполняющего graphql-запрос к SQL-базе данных: query-запрос. Пример.
-----------------------------------DB.js-------------------------------
const mssql = require('mssql/msnodesqlv8');
const config = require('./DBConfig');

function DB(cb) {
	this.getFaculties = (args, context) => {
		return (new mssql.Request())
			.query('select * from FACULTY')
			.then((r) => {
				console.log(r.recordset);
				return r.recordset
			});
	};

	this.getFaculty = (args, context) => {
		return (new mssql.Request())
			.input('faculty', mssql.NVarChar, args.FACULTY)
			.query('select top(1) * from FACULTY where FACULTY = @faculty')
			.then((r) => { return r.recordset; });
	};
	this.connect = mssql.connect(config, () => {
		console.log('Connected to DB');
	})
}

exports.DB = () => { return new DB(); };


------------------------------resolver.js-----------------------------------
const resolver = {
	getFaculties: (args, context) => {
		console.log()
		return (args.FACULTY) ? context.getFaculty(args, context) : context.getFaculties(args, context);
	}
};
module.exports = resolver;
------------------------------schema.gql-----------------------------------------
schema {
  query: Query
}

type FACULTY {
  FACULTY: String!
  FACULTY_NAME: String!
}

type Query {
  getFaculties(FACULTY: String): [FACULTY]
}


60. Разработка приложения, выполняющего graphql-запрос к SQL-базе данных: mutation-запрос. Пример. 
const mssql = require('mssql/msnodesqlv8');
const config = require('./DBConfig');

function DB(cb) {
	this.insertFaculty = (args, context) => {
		return (new mssql.Request())
			.input('a', mssql.NVarChar, args.FACULTY)
			.input('b', mssql.NVarChar, args.FACULTY_NAME)
			.query('insert FACULTY(FACULTY, FACULTY_NAME) values (@a, @b)')
			.then((r) => { return args; });
	};
	this.updateFaculty = (args, context) => {
		return (new mssql.Request())
			.input('a', mssql.NVarChar, args.FACULTY)
			.input('b', mssql.NVarChar, args.FACULTY_NAME)
			.query('update FACULTY set FACULTY = @a, FACULTY_NAME = @b where FACULTY = @a')
			.then((r) => {
				return (r.rowsAffected[0] === 0) ? null : args;
			});
	};
	this.connect = mssql.connect(config, () => {
		console.log('Connected to DB');
	})
}

exports.DB = () => { return new DB(); };
------------------------------resolver.js-----------------------------------
const resolver = {
	setFaculty: (args, context) => {
		return context.updateFaculty(args, context).then((res) => {
			return (res == null) ? context.insertFaculty(args, context) : res;
		});
	}
};
module.exports = resolver;
----------------------------------schema.gql---------------------------------
schema {
  query: Query
  mutation: Mutation
}

type FACULTY {
  FACULTY: String!
  FACULTY_NAME: String!
}

type Query {
  getFaculties(FACULTY: String): [FACULTY]
}
type Mutation {
  setFaculty(FACULTY: String!, FACULTY_NAME: String!): FACULTY
}








